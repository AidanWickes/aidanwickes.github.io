<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Building VR interactives with Three.js</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    html, body { margin:0; padding:0; overflow:hidden;}
    </style>
</head>
<body>
    <script>
    WebVRConfig = {
      // Forces availability of VR mode.
      FORCE_ENABLE_VR: true,
    };
    </script>
    <!-- Assets we'll need - Three.js, controls, and the webVR manager and polyfill -->
    <script src="js/es6-promise.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/three.flycontrols.js"></script>
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>
    <script src="js/webvr-polyfill.js"></script>
    <script src="js/webvr-manager.js"></script>
    <script src="js/audiosynth.js"></script>
    <script src="js/audiosynth.view.js"></script>

    <script>

    Synth instanceof AudioSynth; // true

var testInstance = new AudioSynth;
testInstance instanceof AudioSynth; // true

testInstance === Synth; // true

var piano = Synth.createInstrument('piano');

var raycaster = new THREE.Raycaster(), INTERSECTED;
var mouse = new THREE.Vector2();

    // Width and height of the browser window
    var WINDOW_WIDTH = window.innerWidth;
    var WINDOW_HEIGHT = window.innerHeight;

    // Width and height of the surface we're going to create
    var WORLD_WIDTH = 2000;
    var WORLD_HEIGHT = 1900;

    // Where our lights and cameras will go
    var scene = new THREE.Scene();

    // Keeps track of time
    var clock = new THREE.Clock();

    // How we will see the scene
    var camera = new THREE.PerspectiveCamera(45, WINDOW_WIDTH/WINDOW_HEIGHT, .1, 1000);
  camera.position.set(0, 55, 85);
  camera.lookAt(scene.position);

    // Think of the renderer as the engine that drives the scene
    var renderer = new THREE.WebGLRenderer({antialias: true});

    // Set the pixel ratio of the screen (for high DPI screens)
    renderer.setPixelRatio(window.devicePixelRatio);

    // Set the background of the scene to a orange/red
    renderer.setClearColor(0xffd4a6);

    // Set renderer to the size of the window
    renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    // Append the renderer to the DOM
    document.body.appendChild( renderer.domElement );

    // Apply VR stereo rendering to renderer
    var effect = new THREE.VREffect(renderer);
    effect.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    var manager = new WebVRManager(renderer, effect);

    // Lights!
    var dirLight = new THREE.DirectionalLight( 0xffffff, 0.75);
    dirLight.position.set( -1, 1, 1).normalize();

    var ambiLight = new THREE.AmbientLight(0x999999);

    // Add the lights to the scene
    scene.add(ambiLight);
    scene.add(dirLight);

    function createGeometry(){
      //create a group container
  keysGroup = new THREE.Object3D();

  var whiteKeys = [];
  var blackKeys = [];

  var i = 1;

  for (var x = -70; x <= 65; x += 10) {
    var boxGeometry = new THREE.BoxGeometry(9, 5, 25);
    var boxMaterial = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
    box = new THREE.Mesh(boxGeometry, boxMaterial);

    box.id = i;
    i++;

    box.position.x = x;

    scene.add(box);
    whiteKeys.push(box);
    keysGroup.add(box);
  }

  var count = 1;
  for (var x = -65; x <= 70; x += 10) {
    if (count % 7 == 0){
      count = 1;
    } else if (count == 3){
      count +=1;
    } else {
      var boxGeometry = new THREE.BoxGeometry(9, 7, 15);
      var boxMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
      box = new THREE.Mesh(boxGeometry, boxMaterial);

      box.position.x = x;
      box.position.z = -2;

      scene.add(box);
      blackKeys.push(box);
      keysGroup.add(box);
      count += 1;
    }

  }
  scene.add(keysGroup);
};

document.addEventListener('mousemove', onMouseMove, false);
  document.addEventListener('mousedown', onMouseDown, false);

  function onMouseMove (event){
  mouseX = event.clientX - window.innerWidth / 2;
  mouseY = event.clientY - window.innerHeight / 2;
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

var keyID;

function onMouseDown (){

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(keysGroup.children);
  if (intersects.length > 0) {
    //get id of the clicked object
    console.log(intersects[0].object.id);
    keyID = intersects[0].object.id;
    playNote();
  }
}

function playNote() {
  switch (keyID){
    case 12:
    piano.play('C', 4, 2);
    break;
    case 13:
    piano.play('D', 4, 2);
    break;
    case 14:
    piano.play('E', 4, 2);
    break;
    case 15:
    piano.play('F', 4, 2);
    break;
    case 16:
    piano.play('G', 4, 2);
    break;
    case 17:
    piano.play('A', 4, 2);
    break;
    case 18:
    piano.play('B', 4, 2);
    break;
    case 19:
    piano.play('C', 5, 2);
    break;
    case 20:
    piano.play('D', 5, 2);
    break;
    case 21:
    piano.play('E', 5, 2);
    break;
    case 22:
    piano.play('F', 5, 2);
    break;
    case 23:
    piano.play('G', 5, 2);
    break;
    case 24:
    piano.play('A', 5, 2);
    break;
    case 25:
    piano.play('B', 5, 2);
    break;
    case 26:
    piano.play('C#', 4, 2);
    break;
    case 27:
    piano.play('D#', 4, 2);
    break;
    case 28:
    piano.play('F#', 4, 2);
    break;
    case 29:
    piano.play('G#', 4, 2);
    break;
    case 30:
    piano.play('A#', 4, 2);
    break;
    case 31:
    piano.play('C#', 5, 2);
    break;
    case 32:
    piano.play('D#', 4, 2);
    break;
    case 33:
    piano.play('F#', 4, 2);
    break;
    case 34:
    piano.play('G#', 4, 2);
    break;
    case 35:
    piano.play('A#', 4, 2);
    break;
  };
};


    // Detect mobile devices in the user agent
    var is_mobile= /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Conditionally load VR or Fly controls, based on whether we're on a mobile device
    if (is_mobile) {
        var controls = new THREE.VRControls(camera);
    } else {
        // WASD-style movement controls
        var controls = new THREE.FlyControls(camera);

        // Disable automatic forward movement
        controls.autoForward = false;

        // Click and drag to look around with the mouse
        controls.dragToLook = true;

        // Movement and roll speeds, adjust these and see what happens!
        controls.movementSpeed = 20;
        controls.rollSpeed = Math.PI / 12;
    }

    // Render loop
    // This should go at the bottom of the script.
    function render() {

        // Get the difference from when the clock was last updated and update the controls based on that value.
        var delta = clock.getDelta();
        controls.update(delta);

        // Update the scene through the manager.
        manager.render(scene, camera);

        //update raycaster with mouse movement
    raycaster.setFromCamera(mouse, camera);
    // calculate objects intersecting the picking ray
    var intersects = raycaster.intersectObjects(keysGroup.children);
  //count and look after all objects in the keys group
    if (intersects.length > 0) {
        if (INTERSECTED != intersects[0].object) {
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            //setting up new material on hover
            INTERSECTED.material.emissive.setHex(Math.random() * 0xff00000 - 0xff00000);
        }
    } else {
        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
        INTERSECTED = null;
    }

        // Call the render function again
        requestAnimationFrame( render );

    }

    createGeometry();
    render();

    </script>

</body>
</html>
